{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"treasure_deck_",
				"treasure_deck_location"
			],
			[
				"back",
				"trasureBackImage"
			],
			[
				"tr",
				"treasure_deck"
			],
			[
				"map",
				"locationTreasureMap"
			],
			[
				"isl",
				"island_x_offset"
			],
			[
				"up",
				"updateLocationActionMap"
			],
			[
				"curr",
				"currentActions"
			],
			[
				"cu",
				"currentActions"
			],
			[
				"curre",
				"currentActions"
			],
			[
				"indi",
				"actionIndicators"
			],
			[
				"SDL_R",
				"SDL_Rect"
			],
			[
				"Geta",
				"GetAvailableActions"
			],
			[
				"dest",
				"destination"
			],
			[
				"actions",
				"currentActions"
			],
			[
				"Action",
				"ActionMode"
			],
			[
				"mod",
				"currentMode"
			],
			[
				"plaer",
				"players"
			],
			[
				"Get",
				"GetAvailableActions"
			],
			[
				"get",
				"GetAvailableActions"
			],
			[
				"current",
				"currentActions"
			],
			[
				"use",
				"usedAbility"
			],
			[
				"abi",
				"usedAbility"
			],
			[
				"item",
				"itemWidth"
			],
			[
				"SDL_Re",
				"SDL_Renderer"
			],
			[
				"Create",
				"SDL_CreateTextureFromSurface"
			],
			[
				"loca",
				"locationImageMap"
			],
			[
				"_f",
				"_fi_tex"
			],
			[
				"lo",
				"locationImageMap"
			],
			[
				"Im",
				"ImageLocation"
			],
			[
				"Ima",
				"ImageData"
			],
			[
				"source",
				"SourceImage"
			],
			[
				"front",
				"FrontY"
			],
			[
				"ima",
				"ImageData"
			],
			[
				"crea",
				"createImageData"
			],
			[
				"par",
				"parseAttributes"
			],
			[
				"compi",
				"compileJazz"
			],
			[
				"com",
				"compileJazz"
			],
			[
				"scr",
				"ScriptType"
			],
			[
				"compiled",
				"compiledScripts"
			],
			[
				"sym",
				"symbol"
			],
			[
				"scri",
				"scriptName"
			],
			[
				"func",
				"function_map"
			],
			[
				"al",
				"algorithm"
			],
			[
				"l",
				"length"
			],
			[
				"tokeni",
				"tokenize"
			],
			[
				"toen",
				"tokens"
			],
			[
				"toke",
				"Tokens"
			],
			[
				"game",
				"Game	class"
			],
			[
				"atta",
				"attackers	variable"
			],
			[
				"ra",
				"random	module"
			],
			[
				"writ",
				"writeln	function"
			],
			[
				"con",
				"conv	module"
			],
			[
				"std",
				"stdio	module"
			],
			[
				"ran",
				"range	module"
			],
			[
				"p",
				"primitives"
			],
			[
				"range",
				"InputRange	interface"
			],
			[
				"r",
				"range	module"
			],
			[
				"tex",
				"texHeight	variable"
			],
			[
				"sc",
				"screenHeight	variable"
			],
			[
				"shiftl",
				"shiftLookY	variable"
			],
			[
				"sh",
				"shiftLookX	variable"
			],
			[
				"scre",
				"screenHeight	variable"
			],
			[
				"screen",
				"screenHeight	variable"
			],
			[
				"scree",
				"screenWidth	variable"
			],
			[
				"text",
				"texHeight	variable"
			],
			[
				"_src",
				"_scrTex	variable"
			],
			[
				"_scr",
				"_scrTex	variable"
			],
			[
				"key",
				"keyMapping	variable"
			],
			[
				"j",
				"jaxis"
			],
			[
				"_cu",
				"_currentFrame	variable"
			],
			[
				"_curr",
				"_currentRow	variable"
			],
			[
				"x",
				"X	function"
			],
			[
				"cl",
				"clean	function"
			],
			[
				"im",
				"image_surface	variable"
			],
			[
				"s",
				"scanf	function"
			]
		]
	},
	"buffers":
	[
		{
			"file": "source/maths/vector.d",
			"settings":
			{
				"buffer_size": 6523,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "import derelict.sdl2.sdl;\nimport derelict.sdl2.image;\nimport derelict.sdl2.ttf;\nimport jazz;\nimport std.algorithm;\nimport std.string;\nimport std.array;\nimport std.stdio;\nimport std.typecons;\nimport du;\nalias std.stdio.writeln wl;\nimport fi;\n\nconst auto RGB_Yellow = SDL_Color(255, 255, 0, 0);\nconst auto RGB_Red = SDL_Color(255, 0, 0, 0);\nconst auto RGB_Green = SDL_Color(0, 255, 0, 0);\nconst auto RGB_Blue = SDL_Color(0, 0, 255, 0);\nconst auto RGB_White  = SDL_Color(255, 255, 255, 0);\nconst auto RGB_Black  = SDL_Color(0, 0, 0, 0);\n\nT WRAPP(T)(T x, T max) { return x > max ? x-max : x; }\n\nmixin(DU!q{\n  ActionMode =\n  | NoneActionMode\n  | MoveActionMode of role : Role\n  | ShoreUpActionMode\n  | TradeActionMode of item : Treasure * role : Role\n  | ClaimActionMode\n  | SandbagActionMode of item : Treasure * destination : Location\n  | HelicopterActionMode of item : Treasure * role : Role *  destination : Location\n});\n\nprivate auto toText(ActionMode mode)  \n{\n  if(mode.IsNoneActionMode) return \"None\";\n  if(mode.IsNoneActionMode) return \"None\";\n  if(mode.IsMoveActionMode) return \"Move\";\n  if(mode.IsShoreUpActionMode) return \"ShoreUp\";\n  if(mode.IsTradeActionMode) return \"Trade\";\n  if(mode.IsClaimActionMode) return \"Claim\";\n  if(mode.IsSandbagActionMode) return \"Sandbag\";\n  if(mode.IsHelicopterActionMode) return \"Helicopter\";\n  assert(0);\n}\n\nclass Game\n{    \nprivate:  \n  static immutable int fps = 60;\n  static immutable float delay_time = 1000.0 / fps;\n  static immutable screen_width = 640;\n  static immutable screen_height = 480;\n  static immutable island_x_offset = 5;\n  static treasure_deck_location = tuple(2,13);\n  static flood_deck_location = tuple(3,13);\n  SDL_Window* _window;\n  SDL_Renderer* _renderer;\n  SDL_Surface* _scr;\n  SDL_Surface* _fi_surf;\n  SDL_Texture* _fi_tex;\n  SDL_Texture* _scrTex;\n  TTF_Font* _font;\n  bool gameRunning = false;\n  ForbiddenIsland _fi;\n  int mouseX, mouseY;\n  ActionMode currentMode = new NoneActionMode();\n  int waitingOnUser = false;\n  Action[] currentActions;\n  Tuple!( int, int, const SDL_Color)[] actionIndicators;\n  Action[Tuple!( int, int)] locationActionMap;\n  Tuple!( int, int)[Treasure] locationTreasureMap;\n  int pulseTimer;\n  bool pulse;\n  static immutable trasureBackImage = treasureImageMap[\"Earth\"];\n\npublic:\n  this( ) \n  {         \n  }\n  void Init()\n  {\n    import std.file;\n    import std.path;\n    SDL_Init(SDL_INIT_EVERYTHING);  \n    TTF_Init();\n    \n    _font = TTF_OpenFont(relativePath(r\"..\\kalinga.ttf\").toStringz,24);\n    assert(_font);\n    \n    _window = SDL_CreateWindow(\"Forbidden Island\", SDL_WINDOWPOS_CENTERED,SDL_WINDOWPOS_CENTERED,1600,900,SDL_WINDOW_SHOWN);\n    // SDL_SetWindowFullscreen(_window,SDL_WINDOW_FULLSCREEN);\n    _renderer = SDL_CreateRenderer(_window,-1,0);\n\n    _fi_surf = IMG_Load(relativePath(r\"images\\fi.jpg\").toStringz);\n    assert(_fi_surf);\n\n    _scr = SDL_CreateRGBSurface(0, 1600, 900, 32,\n                                        0x00FF0000,\n                                        0x0000FF00,\n                                        0x000000FF,\n                                        0xFF000000);\n    _scrTex = SDL_CreateTexture(_renderer,\n                                            SDL_PIXELFORMAT_ARGB8888,\n                                            SDL_TEXTUREACCESS_STREAMING,\n                                            640, 480);\n\n    _fi_tex = SDL_CreateTextureFromSurface(_renderer,_fi_surf);\n    assert(_fi_tex);\n\n    _fi.initialize([new Navigator(),new Explorer(), new Engineer(), new Messenger()],2);\n    gameRunning = true;\n  };\n  \n  @system\n  private void pset(int x, int y, const SDL_Color color)\n  {\n    // set individual pixels\n    if(x < 0 || y < 0 || x >= screen_width || y >= screen_height) return;\n    uint colorSDL = SDL_MapRGB(_scr.format, color.r, color.g, color.b);\n    uint* bufp;\n    bufp = cast(uint*)_scr.pixels + y * _scr.pitch / 4 + x;\n    *bufp = colorSDL;\n  }\n\n  void Render(){\n    SDL_FillRect(_scr, null, 0x000000);\n      \n    SDL_UpdateTexture(_scrTex, null, _scr.pixels, _scr.pitch);\n    SDL_RenderClear(_renderer);    \n    SDL_RenderCopy(_renderer, _scrTex, null, null);\n\n    // draw the island tiles\n    SDL_Rect src;\n    src.x=0;\n    src.y=0;\n    src.w=409;\n    src.h=585;\n\n    SDL_Rect dest;\n    dest.x=0;\n    dest.y=0;\n    dest.w=src.w/4;\n    dest.h=src.h/4;\n\n    int width = 409/4;\n    int height = 585/4;\n    int xOffset = width * 5;\n    for(int y = 0; y < 6; y++)\n    {\n      for(int x = 0; x < 6; x++)\n      {\n        if(auto tile = _fi.island[y][x])\n        {\n          auto data = locationImageMap[tile.__tag()];\n          if( tile.Status == LocationStatus.Surface)\n          {\n            src.x = data.FrontCol * data.itemWidth;\n            src.y = data.FrontRow * data.itemHeight;\n            dest.x = x * width + xOffset;\n            dest.y = y * height;\n            SDL_RenderCopy(_renderer, _fi_tex, &src, &dest);\n          }\n          else if( tile.Status == LocationStatus.Sinking)\n          {\n            src.x = data.BackCol * data.itemWidth;\n            src.y = data.BackRow * data.itemHeight;\n            dest.x = x * width + xOffset;\n            dest.y = y * height;\n            SDL_RenderCopy(_renderer, _fi_tex, &src, &dest);\n          }\n        }\n      }\n    }\n\n    import std.conv;\n    import std.string;\n    string s =  currentMode.toText;\n    ShowText(s.toStringz,50,450,255,200,200);\n\n    s = \"Moves Left:\" ~ (3 - _fi.players[_fi.currentPlayer].actionsTaken).to!string;\n    ShowText(s.toStringz,50,480,255,200,200);\n\n    // draw player graphics\n    foreach(i,p;_fi.players)\n    {\n      // first draw the player card indicator\n      auto data = roleImageMap[p.role.__tag()];\n      if(i == 0)\n      {\n        dest.x=0; dest.y=height;      \n      }\n      else if(i == 1)\n      {\n       dest.x=14 * width; dest.y=height; \n      }\n      else if(i == 2)\n      {\n       dest.x=0;dest.y= 4 * height; \n      }\n      else if(i == 3)\n      {\n       dest.x= 14 * width; dest.y= 4 * height; \n      }\n      src.y = data.FrontRow * data.itemHeight;\n      src.x = data.FrontCol * data.itemWidth;\n      SDL_RenderCopy(_renderer, _fi_tex, &src, &dest);\n\n      // if this is the current player, draw a red rectangle around them\n      if(i==_fi.currentPlayer)\n      {\n        SDL_SetRenderDrawColor(_renderer,255,0,0,0);\n        SDL_RenderDrawRect(_renderer,&dest);\n      }\n\n      // reset initial positions for drawing treasure card hands\n      if ( i == 0)\n      {\n        dest.y -= height; \n      }\n      else if(i == 1)\n      {\n        dest.y -= height;\n      }\n      else if ( i == 2)\n      {\n        dest.y += height; \n      }\n      else if ( i == 3)\n      {\n        dest.y += height; \n      }\n      \n      int offset = width;\n      if(i==1 || i == 3)\n      {\n        offset = -offset;\n      }\n\n      // draw treasure cards\n      foreach(c;p.treasureHand.items)\n      {\n        auto treasureData = treasureImageMap[c.__tag()];\n\n        src.y = treasureData.FrontRow * treasureData.itemHeight;\n        src.x = treasureData.FrontCol * treasureData.itemWidth;\n        \n        SDL_RenderCopy(_renderer, _fi_tex, &src, &dest);\n        dest.x += offset;\n      }\n    }    \n\n    // draw the flood and treasure decks / discard \n    // treasure\n    dest.y = treasure_deck_location[0] * height;\n    dest.x = treasure_deck_location[1] * width;\n    src.y = trasureBackImage.BackRow * trasureBackImage.itemHeight;\n    src.x = trasureBackImage.BackCol * trasureBackImage.itemWidth;\n    SDL_RenderCopy(_renderer, _fi_tex, &src, &dest);\n\n    if(_fi.treasureDeck.discard_deck.items.length > 0)\n    {\n\n    }\n\n    if(_fi.floodDeck.discard_deck.items.length > 0)\n    {\n\n    }\n\n    // flood - this is one to the left of the treasure back in the source image\n    // dest.x -= width;\n    dest.y = flood_deck_location[0] * height;\n    dest.x = flood_deck_location[1] * width;\n    \n    src.x -= trasureBackImage.itemWidth;\n    SDL_RenderCopy(_renderer, _fi_tex, &src, &dest);\n\n\n\n    // show available moves depending on mode\n    if(pulse)\n    {\n      foreach(item; actionIndicators)\n      {\n        dest.y = item[0] * height;\n        dest.x = item[1] * width;\n        SDL_SetRenderDrawColor(_renderer,0,item[2].r,item[2].g,item[2].b);  \n        SDL_RenderDrawRect(_renderer,&dest);\n      }\n    }\n    // currentMode.castSwitch!(\n    //   (MoveActionMode x) => {\n    //     foreach(action;filteredActions)\n    //     {\n    //       if(auto move = action.AsMove)\n    //       {\n    //         assert(move.destination);          \n    //         auto position = _fi.FindPosition(move.destination);\n    //         dest.x = position[0] * width + xOffset;\n    //         dest.y = position[1] * height;\n    //         SDL_RenderDrawRect(_renderer,&dest);\n    //       }\n    //     }\n    //   }(),\n      \n    //   (NoneActionMode x) => {}(),\n\n    //   (ShoreUpActionMode x) => {\n    //     // SDL_SetRenderDrawColor(_renderer,255,0,0,0);\n    //     foreach(action;filteredActions)\n    //     {\n    //       if(auto shore = action.AsShore)\n    //       {\n    //         assert(shore.destination);          \n    //         auto position = _fi.FindPosition(shore.destination);\n    //         dest.x = position[0] * width + xOffset;\n    //         dest.y = position[1] * height;\n    //         SDL_RenderDrawRect(_renderer,&dest);\n    //       }\n    //     }\n    //   }(),\n        \n    //   (ClaimActionMode x) => {\n    //     // SDL_SetRenderDrawColor(_renderer,255,0,0,0);\n    //     foreach(action;filteredActions)\n    //     {\n    //       if(auto claim = action.AsClaim)\n    //       {\n    //         //assert(move.destination);          \n    //         //auto position = _fi.FindPosition(move.destination);\n    //         //dest.x = position[0] * width + xOffset;\n    //         //dest.y = position[1] * height;\n    //         //SDL_RenderDrawRect(_renderer,&dest);\n    //       }\n    //     }\n    //   }(),\n      \n    //   (TradeActionMode x) => {}()\n\n    // );\n\n    // draw current card highlight\n    dest.x = (mouseX / width) * width;\n    dest.y = (mouseY / height) * height;\n    SDL_SetRenderDrawColor(_renderer,255,0,255,0);\n    SDL_RenderDrawRect(_renderer,&dest);\n\n    SDL_RenderPresent(_renderer);\n  }\n\n\n  private void updateTreasureLocationMaps()\n  {\n    foreach(k;locationTreasureMap.keys)\n    {\n      locationTreasureMap.remove(k);\n    }\n    int width = 409/4;\n    int height = 585/4;\n    \n    foreach(i,p;_fi.players)\n    {\n      int x,y;\n      if(i == 0)\n      {\n        x=0; y=0;\n      }\n      else if(i == 1)\n      {\n       x=14 * width; y=0; \n      }\n      else if(i == 2)\n      {\n       x=0;y= 5 * height; \n      }\n      else if(i == 3)\n      {\n       x= 14 * width; y= 5 * height; \n      }\n\n      foreach(t;p.treasureHand)\n      {\n        int offset = width;\n        if(i==1 || i == 3)\n        {\n          offset = -offset;\n        }\n\n        x+=offset;\n\n        locationTreasureMap[t] = tuple(y,x);\n      }\n    }\n  }\n\n  private void updateLocationActionMap()\n  {\n    foreach(key;locationActionMap.keys)\n    {\n      locationActionMap.remove(key);\n    }\n    actionIndicators = [];\n\n    // filteredActions = currentActions.filter!(x=>x.IsDiscard || x.IsDrawTreasure || x.IsDrawFlood\n    //                                          || x.IsWatersRiseAction || x.IsTileFloods\n    //                                          /*|| x.IsHelicopterLiftAction || x.IsSandbagAction*/).array;\n    \n    void addGlobalActions()\n    {\n      foreach(action;currentActions)\n      {\n        if(auto x = action.AsDiscard)\n        {\n\n        }\n        else if(auto x = action.AsDrawTreasure)\n        {\n          locationActionMap[treasure_deck_location] = x;\n          actionIndicators ~= tuple(treasure_deck_location[0],treasure_deck_location[1],RGB_Green);\n        }\n        else if(auto x = action.AsDrawFlood) \n        {\n\n        }\n        else if(auto x = action.AsWatersRiseAction)\n        {\n\n        }\n        else if(auto x = action.AsTileFloods)\n        {\n\n        }\n        else if(auto x = action.AsHelicopterLiftAction)\n        {\n          \n        }\n        else if(auto x = action.AsSandbagAction)\n        {\n          \n        }\n      }\n    }\n\n    // add mode specific action highlights and location map entries\n    currentMode.castSwitch!(\n      (MoveActionMode x) => {\n        foreach(action;currentActions)\n        {\n          if(auto move = action.AsMove)\n          {\n            if(x.role == move.source)\n            {\n              auto coords = _fi.FindLocationCoordinates(move.destination);\n              coords[1] += island_x_offset;\n              locationActionMap[coords] = move;\n              actionIndicators ~= tuple(coords[0],coords[1],RGB_Green);              \n            }\n          }          \n        }\n        addGlobalActions();\n      }(),\n\n      (NoneActionMode x) => {\n        addGlobalActions();\n      }(),\n\n      (ShoreUpActionMode x) => {\n        foreach(action;currentActions)\n        {\n          if(auto move = action.AsShore)\n          {\n            auto coords = _fi.FindLocationCoordinates(move.destination);\n            coords[1] += island_x_offset;\n            locationActionMap[coords] = move;\n            actionIndicators ~= tuple(coords[0],coords[1],RGB_Green);\n          }\n        }\n        addGlobalActions();\n      }(),\n\n      (ClaimActionMode x) => {\n        foreach(action;currentActions)\n        {\n          if(auto claim = x.AsClaim)\n          {\n            auto coords = _fi.FindLocationCoordinates(_fi.players[_fi.currentPlayer].location);\n            coords[1] += island_x_offset;\n            locationActionMap[coords] = claim; \n          }\n        }\n        addGlobalActions();\n      }(),\n      \n      (TradeActionMode x) => {\n        addGlobalActions();\n      }()\n\n      \n    );\n\n\n\n  }\n\n  private void ShowText(const(char)* text, int x, int y, ubyte r, ubyte g, ubyte b)\n  {\n    SDL_Color text_colour = SDL_Color(r,g,b);\n    SDL_Surface* surface;\n    scope(exit) SDL_FreeSurface(surface);    \n    surface = TTF_RenderText_Solid(_font,text,text_colour);\n    SDL_Texture* font_tex = SDL_CreateTextureFromSurface(_renderer,surface);\n    scope(exit) SDL_DestroyTexture(font_tex);\n    SDL_Rect dest;\n    dest.x=x;\n    dest.y=y;\n    SDL_QueryTexture(font_tex, null, null, &dest.w,&dest.h);\n    SDL_RenderCopy(_renderer, font_tex, null, &dest);\n\n  }\n\n  void Update() {\n    import std.algorithm : each;\n    pulseTimer = WRAPP(pulseTimer+1,30);\n    if(pulseTimer == 1)\n    {\n      pulse = !pulse;\n    }\n\n    if(!waitingOnUser)\n    {\n      writeln(\"getting new actions..\");\n      currentActions = _fi.GetPlayerActions();\n      updateLocationActionMap();\n      updateTreasureLocationMaps();\n      waitingOnUser = true;\n    }\n  };\n  \n  Uint8* _keyState;  \n  \n  bool IsKeyDown(SDL_Scancode code){ return _keyState[code] == 1; }\n  \n  void HandleEvents()  {\n    _keyState = SDL_GetKeyboardState(null);\n    if(IsKeyDown(SDL_SCANCODE_ESCAPE)) {\n      gameRunning=false;\n    }\n\n    SDL_Event event;\n    while (SDL_PollEvent(&event))\n    {\n      switch(event.type)\n      {\n        case SDL_KEYDOWN:\n          switch(event.key.keysym.sym)\n          {\n            case 'm':\n            {\n              currentMode = new MoveActionMode(_fi.CurrentRole);\n              updateLocationActionMap();\n              break;\n            }            \n            case 's':\n            {\n              currentMode = new ShoreUpActionMode();\n              updateLocationActionMap();\n              break;\n            }  \n             case 'c':\n            {\n              currentMode = new ClaimActionMode();\n              updateLocationActionMap();\n              break;\n            }  \n             case 't':\n            {\n              currentMode = new TradeActionMode(null,null);\n              updateLocationActionMap();\n              break;\n            }  \n            default:\n            break;\n          }\n          break;\n        case SDL_MOUSEMOTION:\n          mouseX = event.motion.x;\n          mouseY = event.motion.y;\n          break;\n        case SDL_MOUSEBUTTONUP:\n          if(event.button.button == SDL_BUTTON_LEFT)\n          {\n            mouseX = event.button.x;\n            mouseY = event.button.y;\n            MouseClick();\n          }\n          break;\n        case SDL_QUIT:\n          gameRunning=false;\n        break;\n\n        default:\n        break;  \n      }\n    }\n    //InputHandler.Update();\n  };\n\n  void MouseClick()\n  {\n    if(waitingOnUser)\n    {\n      int x, y;\n      int width = 409/4;\n      int height = 585/4;\n      int xOffset = width * 5;\n      x = (mouseX / width) ;\n      y = (mouseY / height);\n      if(auto action = tuple(y,x) in locationActionMap)\n      {\n        _fi.ProcessAction(*action);\n        waitingOnUser = false;\n      }\n  \n      x = (mouseX / width) * width;\n    }\n  }\n  void Clean()  {\n    //InputHandler.Clean();\n    SDL_DestroyWindow(_window);\n    SDL_DestroyRenderer(_renderer);\n    SDL_Quit();\n  };\n\n  @property bool running() { return gameRunning; }\n}\n\nvoid main(){\n  DerelictSDL2.load();\n  DerelictSDL2Image.load();\n  DerelictSDL2ttf.load();\n  auto game = new Game();  \n  uint frameStart, frameTime;\n  game.Init();\n  wl(\"init \", Game.delay_time);\n  while(game.running)\n  {\n    frameStart = SDL_GetTicks();\n    game.HandleEvents();\n    game.Update();\n    game.Render();\n\n    frameTime = SDL_GetTicks() - frameStart;\n    if( frameTime < Game.delay_time )\n    {\n      SDL_Delay(cast(int)Game.delay_time-frameTime);\n    }\n    else \n    {\n      // writeln(\"ouch \", frameTime - Game.delay_time, \" \", frameTime); \n    }\n    \n  }\n  game.Clean();\n}\n",
			"file": "source/app.d",
			"file_size": 18050,
			"file_write_time": 130912341752215687,
			"settings":
			{
				"buffer_size": 17454,
				"line_ending": "Windows"
			}
		},
		{
			"file": "source/fi.d",
			"settings":
			{
				"buffer_size": 21245,
				"line_ending": "Windows"
			}
		},
		{
			"file": "source/functional/record.d",
			"settings":
			{
				"buffer_size": 4203,
				"line_ending": "Windows"
			}
		},
		{
			"file": "source/functional/metafunc.d",
			"settings":
			{
				"buffer_size": 2504,
				"line_ending": "Windows"
			}
		},
		{
			"file": "source/jazz/jazz.d",
			"settings":
			{
				"buffer_size": 7806,
				"line_ending": "Windows",
				"name": "module jazz"
			}
		},
		{
			"file": "source/deck.d",
			"settings":
			{
				"buffer_size": 3434,
				"line_ending": "Windows"
			}
		},
		{
			"file": "source/functional/du.d",
			"settings":
			{
				"buffer_size": 5630,
				"line_ending": "Windows"
			}
		},
		{
			"file": "source/scratchpad.d",
			"settings":
			{
				"buffer_size": 3320,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "Packages/DKit/D.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/AAAPackageDev/Support/Convert to ....sublime-build",
					""
				],
				[
					"Packages/AAAPackageDev/Support/Convert to ....sublime-build",
					"JSON"
				],
				[
					"Packages/AAAPackageDev/Support/Convert to ....sublime-build",
					"Property List"
				],
				[
					"Packages/AAAPackageDev/Support/Convert to ....sublime-build",
					"YAML (Block Style)"
				],
				[
					"Packages/AAAPackageDev/Support/Convert to ....sublime-build",
					"YAML (Default Style)"
				]
			],
			[
				"Packages/AAAPackageDev/Support/Convert to ....sublime-build",
				""
			]
		],
		[
			[
				[
					"Packages/DKit/D.sublime-build",
					""
				],
				[
					"Packages/DKit/D.sublime-build",
					"Run"
				],
				[
					"Packages/DKit/D.sublime-build",
					"dub"
				]
			],
			[
				"Packages/DKit/D.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 375.0,
		"last_filter": "D",
		"selected_items":
		[
			[
				"D",
				"Set Syntax: D (Colorcode)"
			],
			[
				"top",
				"Build output always at top"
			],
			[
				"D c",
				"Set Syntax: D (Colorcode)"
			],
			[
				"d",
				"Set Syntax: D"
			],
			[
				"COL",
				"Set Syntax: D (Colorcode)"
			],
			[
				"fo",
				"Code Folding: Fold Tag Attributes"
			],
			[
				"go",
				"Set Syntax: Go (Colorcode)"
			],
			[
				"cloj",
				"Set Syntax: Clojure"
			],
			[
				"li",
				"Set Syntax: Lisp"
			],
			[
				"build",
				"Build output always at top"
			],
			[
				"g",
				"Set Syntax: Go (Colorcode)"
			],
			[
				"in",
				"Indent JSON"
			],
			[
				"js",
				"Set Syntax: JSON"
			],
			[
				"he",
				"Hex Viewer: Toggle Hex View"
			],
			[
				"ui",
				"Generate UUID v4"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"hex",
				"Hex Viewer: Toggle Hex View"
			],
			[
				"Package Control: list",
				"Package Control: List Packages"
			],
			[
				"buil",
				"Build output always at top"
			],
			[
				"none",
				"Set Syntax: Python (Colorcode)"
			],
			[
				"GO",
				"Set Syntax: Go (Colorcode)"
			],
			[
				"bui",
				"Build output always at top"
			],
			[
				"b",
				"Build output always at top"
			],
			[
				"side",
				"View: Toggle Side Bar"
			],
			[
				"co",
				"Set Syntax: Go (Colorcode)"
			],
			[
				"Go",
				"Set Syntax: Go (Colorcode)"
			],
			[
				"can",
				"Build: Cancel"
			],
			[
				"ca",
				"Build: Cancel"
			],
			[
				"buildc",
				"Build: Cancel"
			],
			[
				"colo",
				"Set Syntax: Go (Colorcode)"
			],
			[
				"wra",
				"Word Wrap: Toggle"
			],
			[
				"wr",
				"Word Wrap: Toggle"
			],
			[
				"wrap",
				"Word Wrap: Toggle"
			],
			[
				"db",
				"Set Syntax: D Build Output"
			],
			[
				"cover",
				"Build With: Convert to ..."
			],
			[
				"conv",
				"Build With: Convert to ..."
			],
			[
				"conver",
				"Build With: Convert to ..."
			],
			[
				"aa",
				"z:AAAPackageDev: Convert (YAML, JSON, PList) to…"
			],
			[
				"new sy",
				"z:AAAPackageDev: New YAML Syntax Definition"
			],
			[
				"col",
				"Set Syntax: C++ (Colorcode)"
			],
			[
				"si",
				"View: Toggle Side Bar"
			],
			[
				"togg",
				"View: Toggle Side Bar"
			],
			[
				"w",
				"Word Wrap: Toggle"
			],
			[
				"snippet fo",
				"Snippet: foreach(e; …) { … }"
			],
			[
				"upper",
				"Convert Case: Upper Case"
			],
			[
				"dc",
				"DKit: List Installed DUB Packages"
			],
			[
				"ins",
				"Package Control: Install Package"
			]
		],
		"width": 506.0
	},
	"console":
	{
		"height": 151.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = 'eb2297e1a458f27d836c04bb0cbaf282' + 'd0e7a3098092775ccb37ca9d6b2e4b7d'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/F/GIT/Drey",
		"/F/GIT/Drey/.dub",
		"/F/GIT/Drey/source",
		"/F/GIT/Drey/source/jazz",
		"/F/GIT/Drey/source/maths"
	],
	"file_history":
	[
		"/F/GIT/Drey/source/app.d",
		"/F/GIT/Drey/source/jazz/scripts/attack1.jazz",
		"/C/Users/Juan/AppData/Roaming/Sublime Text 3/Packages/User/DUB-Build.sublime-build",
		"/C/Users/Juan/AppData/Roaming/Sublime Text 3/Packages/User/DUB.sublime-build",
		"/F/GIT/Drey/source/slisp.d",
		"/C/Users/Juan/AppData/Roaming/Sublime Text 3/Packages/User/DUB-Prof.sublime-build",
		"/F/GIT/Drey/source/scratchpad.d",
		"/F/GIT/Autumn/Samples/SimpleSQL/bin/Debug/SimpleSQL.sql[MySchema]-[NewEntity].aobj",
		"/F/autumn/Autumn.Web/Web.config",
		"/F/ZORK1.DAT",
		"/I/ZORK1.DAT",
		"/F/GIT/Autumn/Samples/SimpleSQL/SimpleSQL/Model1.adm",
		"/F/GIT/Autumn/Samples/SimpleSQL/SimpleSQL/sql.eq",
		"/F/autumn/Autumn/SalesLogix/Model.adm",
		"/F/GIT/SQLProvider/src/SQLProvider/SqlRuntime.Linq.fs",
		"/F/GIT/SQLProvider/src/SQLProvider/SqlRuntime.Patterns.fs",
		"/F/GIT/Drey/trace.log",
		"/E/rispy.rb",
		"/C/Users/Juan/AppData/Roaming/Sublime Text 3/Packages/User/dbuild.YAML-tmLanguage",
		"/F/GIT/Drey/source/maths/vector.d",
		"/F/GIT/Squirrelatron/source/Vector2D.d",
		"/F/GIT/Squirrelatron/source/Vector.d",
		"/F/GIT/Squirrelatron/source/app.d",
		"/F/GIT/Squirrelatron/source/Invaders.d",
		"/F/GIT/Squirrelatron/source/InputHandler.d",
		"/F/GIT/Squirrelatron/source/Workshop.d",
		"/F/GIT/Squirrelatron/source/TextureManager.d",
		"/F/GIT/Squirrelatron/source/BackgroundEffects.d",
		"/F/GIT/Squirrelatron/source/Maths/Vectors.d",
		"/C/Users/Juan/Documents/Visual Studio 2013/Projects/ConsoleApp1/ConsoleApp1/source/tcod/c/types.d",
		"/C/Users/Juan/Documents/Visual Studio 2013/Projects/ConsoleApp1/ConsoleApp1/main.d",
		"/C/Users/Juan/Documents/Visual Studio 2013/Projects/ConsoleApp1/ConsoleApp1/source/app.d",
		"/C/Users/Juan/Documents/Visual Studio 2013/Projects/ConsoleApp1/ConsoleApp1/source/tcod/c/functions.d",
		"/C/Users/Juan/Documents/Visual Studio 2013/Projects/ConsoleApp1/ConsoleApp1/tcod/c/functions.d",
		"/F/GIT/libtcod-d/source/tcod/c/functions.d",
		"/C/Users/Juan/Documents/Visual Studio 2013/Projects/ConsoleApp1/ConsoleApp1/source/tcod/c/all.d",
		"/C/Users/Juan/Documents/Visual Studio 2013/Projects/ConsoleApp1/ConsoleApp1/source/dumpground.d",
		"/C/Users/Juan/Documents/Visual Studio 2013/Projects/ConsoleApp1/ConsoleApp1/dataStructures.d",
		"/C/Users/Juan/AppData/Roaming/Sublime Text 3/Packages/DKit/DKit.sublime-settings",
		"/F/utils/Sublime Text 3/Packages/D.sublime-package",
		"/C/Users/ross/AppData/Roaming/Sublime Text 3/Packages/User/DUB.sublime-build",
		"/C/Users/ross/Documents/DCD/makefile",
		"/C/Program Files/Sublime Text 3/Packages/D.sublime-package"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 93.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"wl",
			"treasure_deck",
			"Yellow",
			"255",
			"0",
			"const",
			"filterCurrentActions",
			"locationTreasureMap",
			"else",
			"As",
			")",
			"showte",
			".As",
			"return",
			"auto x = ",
			"=",
			" =",
			"=>",
			"x",
			"ActionMode.",
			"static",
			"__tag()",
			"tagMethod",
			"move",
			"!is",
			"x",
			"currentMode",
			"ttf",
			"text",
			"int",
			"createte",
			"ImageLocation(ImageType.back,",
			"ImageLocation(ImageType.front",
			"rect2",
			"rect",
			"y",
			"_fi_image",
			"_fi_tex",
			"Y",
			"X",
			"))",
			")",
			"@",
			"ArtifactLocation",
			"StartPosition",
			"ImageLocation(ImageType.front,2,7)",
			"Member",
			"member",
			"\\",
			"=",
			"define",
			"e",
			"function_map[symbol.name]",
			"not mapp",
			"format",
			"atom",
			"SExpression",
			"struct",
			"n(",
			"mixin",
			"Token",
			"n",
			")",
			")\n",
			"outer",
			"{\n",
			"game",
			"Game",
			"game",
			"token",
			"Atom",
			"cell",
			"tokens2",
			"ushort",
			"angle",
			"enum",
			"auto",
			"alias",
			";",
			"records.header",
			"john",
			"float",
			"vecType",
			"z",
			"d",
			"c",
			"b",
			"data",
			"TL",
			"isFloatVector",
			"this.data",
			"data",
			"tunn",
			"h",
			"w",
			"h",
			"w",
			"W",
			"w",
			"y",
			"x",
			"f1_v",
			"48",
			"y",
			"x",
			"h",
			"w",
			"ubyte",
			"scr->",
			"Uint32",
			"scre",
			"angle",
			"Base",
			"0.0",
			"MainPad",
			"InputHandler.MainPad",
			"Movement",
			"Left",
			"left",
			"Movement",
			"LeftStick",
			"RightStick",
			"float",
			"x",
			"X",
			"x",
			"X",
			"load"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "source/maths/vector.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6523,
						"regions":
						{
						},
						"selection":
						[
							[
								1583,
								1583
							]
						],
						"settings":
						{
							"auto_name": "",
							"colorcode": true,
							"forcecolorcode": false,
							"syntax": "Packages/Colorcoder/Go (Colorcoded).tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1092.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "source/app.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17454,
						"regions":
						{
						},
						"selection":
						[
							[
								7551,
								7551
							]
						],
						"settings":
						{
							"colorcode": true,
							"history_list_is_closing": true,
							"syntax": "Packages/Colorcoder/Go (Colorcoded).tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4338.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "source/fi.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 21245,
						"regions":
						{
						},
						"selection":
						[
							[
								12247,
								12247
							]
						],
						"settings":
						{
							"colorcode": true,
							"syntax": "Packages/Colorcoder/Go (Colorcoded).tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 9902.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "source/functional/record.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4203,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"colorcode": true,
							"syntax": "Packages/D/D.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "source/functional/metafunc.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2504,
						"regions":
						{
						},
						"selection":
						[
							[
								417,
								417
							]
						],
						"settings":
						{
							"colorcode": true,
							"syntax": "Packages/D/D.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 108.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "source/jazz/jazz.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7806,
						"regions":
						{
						},
						"selection":
						[
							[
								197,
								197
							]
						],
						"settings":
						{
							"auto_name": "module jazz",
							"colorcode": true,
							"syntax": "Packages/D/D.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 306.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "source/deck.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3434,
						"regions":
						{
						},
						"selection":
						[
							[
								2153,
								2153
							]
						],
						"settings":
						{
							"colorcode": true,
							"syntax": "Packages/D/D.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "source/functional/du.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5630,
						"regions":
						{
						},
						"selection":
						[
							[
								4189,
								4189
							]
						],
						"settings":
						{
							"colorcode": true,
							"syntax": "Packages/Colorcoder/Go (Colorcoded).tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 3132.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "source/scratchpad.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3320,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"colorcode": true,
							"syntax": "Packages/D/D.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				}
			]
		},
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 2,
					"file": "source/fi.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 21245,
						"regions":
						{
						},
						"selection":
						[
							[
								7195,
								7195
							]
						],
						"settings":
						{
							"colorcode": true,
							"syntax": "Packages/Colorcoder/Go (Colorcoded).tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 5315.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "source/deck.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3434,
						"regions":
						{
						},
						"selection":
						[
							[
								2654,
								2654
							]
						],
						"settings":
						{
							"colorcode": true,
							"syntax": "Packages/D/D.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 2604.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "source/app.d",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17454,
						"regions":
						{
						},
						"selection":
						[
							[
								961,
								961
							]
						],
						"settings":
						{
							"colorcode": true,
							"history_list_is_closing": true,
							"syntax": "Packages/Colorcoder/Go (Colorcoded).tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 36.0
	},
	"input":
	{
		"height": 36.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.5,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 239.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.hex_viewer_inspector":
	{
		"height": 124.0
	},
	"output.package_dev":
	{
		"height": 124.0
	},
	"pinned_build_system": "Packages/User/DUB.sublime-build",
	"project": "drey.sublime-project",
	"replace":
	{
		"height": 50.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"app",
				"source\\app.d"
			],
			[
				"a",
				"source\\app.d"
			],
			[
				"du",
				"source\\functional\\du.d"
			],
			[
				"fi",
				"source\\fi.d"
			],
			[
				"fo",
				"source\\functional\\record.d"
			],
			[
				"meta",
				"source\\functional\\metafunc.d"
			],
			[
				"v",
				"source\\maths\\vector.d"
			],
			[
				"ve",
				"source\\maths\\vector.d"
			],
			[
				"ap",
				"source\\app.d"
			],
			[
				"",
				"source\\Maths\\Vector.d"
			],
			[
				"tex",
				"source\\TextureManager.d"
			],
			[
				"wok",
				"source\\workshop.d"
			],
			[
				"b",
				"source\\BackgroundEffects.d"
			],
			[
				"pp",
				"source\\app.d"
			],
			[
				"inpu",
				"source\\InputHandler.d"
			],
			[
				"bac",
				"source\\BackgroundEffects.d"
			],
			[
				"ba",
				"source\\BackgroundEffects.d"
			],
			[
				"inv",
				"source\\Invaders.d"
			],
			[
				"gam",
				"source\\GameObjects.d"
			],
			[
				"pl",
				"C:\\Users\\Juan\\AppData\\Roaming\\Sublime Text 3\\Packages\\User\\DUB.sublime-build"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"F:\\utils\\D\\dmd2\\src\\phobos\\std\\phobos.sublime-workspace"
			],
			[
				"pla",
				"F:\\GIT\\dplayground\\dplayground.sublime-project"
			],
			[
				"p",
				"F:\\utils\\D\\dmd2\\src\\phobos\\std\\phobos.sublime-project"
			]
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 60.0,
		"last_filter": "render",
		"selected_items":
		[
			[
				"render",
				"Render"
			],
			[
				"ren",
				"Render"
			],
			[
				"RENDER",
				"Render"
			],
			[
				"mouse",
				"MouseClick"
			],
			[
				"process",
				"ProcessAction"
			],
			[
				"geta",
				"GetAvailableActions"
			],
			[
				"updatelo",
				"updateLocationActionMap"
			],
			[
				"play",
				"Player"
			],
			[
				"player",
				"Player"
			],
			[
				"getpl",
				"GetPlayerActions"
			],
			[
				"update",
				"updateMaps"
			],
			[
				"upda",
				"Update"
			],
			[
				"fi",
				"ForbiddenIsland"
			],
			[
				"en",
				"Environment"
			]
		],
		"width": 378.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": false,
	"side_bar_width": 193.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
